---
title: Querying data in a Jupyter Notebook
author: David G. Simmons
author_title: QuestDB Team
author_url: https://github.com/davidgs
author_image_url: https://avatars.githubusercontent.com/davidgs
description:
  Use a Jupyter notebook to create a database, insert and query data and graph
  the results using Python.
tags: [tutorial, python, pandas, jupyternotebook]
image: /img/blog/2020-06-15/banner.png
slug: querying-data-jupyter-noteboook
---

import Banner from "@theme/Banner"

<Banner
  alt="Flow chart of QuestDB database, analytic tools, and data visualization"
  height={365}
  src="/img/blog/2020-06-15/banner.png"
  width={650}
></Banner>

In this tutorial, we will explore how to use QuestDB in combination with a
Jupyter notebook by following the steps to generate a database, execute queries,
import contents into a Pandas dataframe, and use `matplotlib` to visualize the
data.

## Getting started

You'll need a few things installed and set up to get started.

- QuestDB: [Install QuestDB](/docs/#get-started).

- Jupyter Notebooks: These interactive Python environments will help you run
a complete version of this tutorial.

To run it, you should:

- install Jupyter Notebooks
- make sure that the libraries we use in this
  tutorial are also installed:

  ```shell
  pip3 install --upgrade ipython jupyter
  pip3 install requests matplotlib pandas
  ```

- clone [this repository](https://github.com/davidgs/QuestNotebook)
  (`git clone https://github.com/davidgs/QuestNotebook`) in the repository
  directory running Jupyter Notebook
<!--https://github.com/questdb/QuestNotebook-->
- Start a Jupyter Notebook by running:
  ```shell
  jupyter notebook
  ```
  Select `QuestNotebook.ipynb`

That will get you right back to a page that looks very similar to this that is
interactive, allowing you to run the code and interact with the database
yourself.

## Create a database

We will use QuestDB as our data storage and interact with it via HTTP REST API.
We will create a simple table with 5 columns, including one for timestamp:

- `cust_id` is the customer identifier. It uniquely identifies a customer.

- `balance_ccy` balance currency. We use [`SYMBOL`](/docs/concept/symbol/) to
  save disk space and increase database performance.

- `balance` is the current balance for customer and currency tuple.

- `inactive` is used to flag deleted records.

- `timestamp` timestamp in microseconds of the record. Note that if you receive
  the timestamp data as a string, it could also be inserted using
  `to_timestamp`.

This should return a `200` status the first time you run it. If you run it more
than once, subsequent runs will return `400` because the database already
exists:

```python
import requests 
import urllib.parse as par
  q = 'create table balances'\
    '(cust_id int,'\
    ' balance_ccy symbol,'\
    'balance double,'\
    'inactive boolean,'\
    'timestamp timestamp)'\
    'timestamp(timestamp)'
  r = requests.get("http://localhost:9000/exec?query=" + q)
  print(r.status_code)
```

## Generate some data

Since we have a new table, we should insert data. We will add some random data
for now. You can re-run this section as many times as you want to add 100
entries at a time, or simply change the `range(100)` to add as many datapoints
as you wish.

```python
import requests
import random
from datetime import datetime

success = 0
fail = 0
currency = ["USD", "EUR", "GBP", "JPY"]
random.seed()

for x in range(100):
  cust = random.randint(20, 42)
  cur = random.choice(currency)
  bal = round(random.uniform(10.45, 235.15), 2)
  act = bool(random.getrandbits(1))
  query = "insert into balances values("\
      + str(cust) + ",'"\
      + cur + "'," \
      + str(bal) + "," \
      + str(act) + ",systimestamp())"
  r = requests.get("http://localhost:9000/exec?query=" + query)
  if r.status_code == 200:
    success += 1
  else:
    fail += 1
  print("Rows inserted: " + str(success))
  if fail > 0:
    print("Rows Failed: " + str(fail))
```

## Query data from QuestDB

Now that we have data available, let's try querying it to see what we get back:

```python
import requests
import io

r = requests.get("http://localhost:9000/exp?query=select * from balances")
rawData = r.text
print(rawData)
```

## Read the content into Pandas DataFrame

So you'll notice that the returned data is just a massive CSV string. If you'd
rather have JSON data, then you would change the endpoint to
`http://localhost:9000/exec`, but since we're going to use Pandas to frame our
data, we'll stick with CSV.

We are also telling pandas to parse the `timestamp` field as a date. This is
important since we're dealing with time series data.

```python
import pandas as pd

pData = pd.read_csv(io.StringIO(rawData), parse_dates=['timestamp'])
print(pData)
```

## Narrow the search

That's just getting us all the data, but let's narrow the search using some SQL
clauses. Let's look for a specific `cust_id` and only balances of that customer
that are in USD.

We are also only interested in data when the customer was active. SQL gives us
the flexibility to specify our search. All of the data was generated randomly,
so this exact query may return no results, you may have to adjust the `cust_id`
below until you get results back.

**Note:** The query string must be URL-encoded before it is sent.

```python
import urllib.parse

q = "select cust_id,"\
    " balance,"\
    " balance_ccy,"\
    " inactive,"\
    " timestamp"\
    " from balances"\
    " where cust_id = 26"\
    " and balance_ccy = 'USD'"\
    " and not inactive"

query = urllib.parse.quote(q)
r = requests.get("http://localhost:9000/exp?query=" + query)
queryData = r.text
rawData = pd.read_csv(queryData.decode('utf-8'), parse_dates=['timestamp']))
print(rawData)
```

## Plot the data

We will use `matplotlib` to plot the data

```python
from matplotlib import pyplot as plt

rawData.plot("timestamp", ["balance"], subplots=True)
```

From that query we should get a nice little plot of our data, like this:

![Graph of the balance from the query](/img/blog/2020-06-15/graph.png)

Data visualization allows us to easily identify the trends of our query.

## Clean up

Now we will clean everything up for the next time.

```python
r = requests.get("http://localhost:9000/exec?query=drop table balances")
if r.status_code == 200:
  print("Database Table dropped")
else:
  print("Database Table not Dropped: " + str(r.status_code))
```

You can now stop your QuestDB instance, if you'd like, or leave it running and
find some great uses for it!

## Additional information

We also built a project, [`play`](https://play.questdb.io/), for anyone to try our database
with a Jupyter Notebook, data, sample code, queries, and graphs.

If you enjoyed this tutorial, please
[follow us](https://twitter.com/intent/follow?screen_name=QuestDB) on Twitter,
and make sure you give our
[GitHub repository](https://github.com/questdb/questdb) a star!
